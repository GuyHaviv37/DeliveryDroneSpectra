import "./imports/DwyerPatterns.spectra"

spec DeliveryDroneMain

// types
type houseOptions = { EMPTY , SMALL };
type warehouseOptions = { EMPTY , PRIORITY , SMALL };
type Cord = Int(0..GRID_DIM);

// Defines
// drone[0] is row , drone[1] is column
// Specify locations of warehouse, charging station and houses on the grid
define
	GRID_DIM := 3; //actually 3+1
	
define
	atWarehouse := drone[0] = 3 & drone[1] = 3;
	atChargingStation := drone[0] = 2 & drone[1] = 3;
	atHouse1 := drone[0] = 0 & drone[1] = 0;
	atHouse2 := drone[0] = 0 & drone[1] = 2;
	atHouse3 := drone[0] = 2 & drone[1] = 0;
	atHouse4 := drone[0] = 2 & drone[1] = 2;

define
	NUM_OF_HOUSES := 4;
	NUM_OF_HOUSES_MINUS_ONE := 3;

define CAPACITY := 4;

define 
	smallPackagePicked := pickUpThisState > 0 & pickUpThisState <9;
	priorityPackagePicked := pickUpThisState >=9;
	packPicked := pickUpThisState >0; 
	
define priorityWaiting := waitingPriorityPackageInWarehouseToHouse1 | 
						waitingPriorityPackageInWarehouseToHouse2 | 
						waitingPriorityPackageInWarehouseToHouse3 | 
						waitingPriorityPackageInWarehouseToHouse4;
define
	smallPackageDelivered := dropOffThisState >0;
	//think about make the drone drop off priority package a soon as it can

define roomForSmallPickup := totalSmallPackages + 1 <= CAPACITY;

define MAX_ENERGY:= 7;

//predicates
predicate moveDir(Cord pos):
  pos+1 = next(pos) |
  pos   = next(pos) |
  pos-1 = next(pos); 
  
// env variables
env houseOptions[NUM_OF_HOUSES] outHousePackages;
env warehouseOptions[NUM_OF_HOUSES] outWarehousePackages;


// sys variables
sys Cord[2] drone;
sys Int(0..12) pickUpThisState;
// 0 - no pickup , 1-4 house small pickups by # , 
// 5-8 warehouse regular pickup to house (#-4), 9-12 warehouse priority big pickup to house (#-8)

sys Int(0..5) dropOffThisState;
// 0 - no drop-off , 1-4 house drop-offs by #, 5 - warehouse drop-off 


// assumptions
// Init houses output to be empty at start of the simulation
asm initHousesEmpty:
forall i in Int(0..NUM_OF_HOUSES_MINUS_ONE) .
		outHousePackages[i] = EMPTY;

// assumptions
// Init houses output to be empty at start of the simulation
asm initWarehouseEmpty:
forall i in Int(0..NUM_OF_HOUSES_MINUS_ONE) .
		outWarehousePackages[i] = EMPTY;
		
/* INVENTORY */
counter totalSmallPackages(0..CAPACITY){
	totalSmallPackages =0;
	inc: packPicked;
	dec: smallPackageDelivered;
	overflow:false;
	underflow:false;
}

// counter for packages from Houses -> Warehouse
counter droneToWarehouseCap(0..CAPACITY){
	droneToWarehouseCap = 0;
	inc: (pickUpThisState>=1) & (pickUpThisState<=4);
	dec: dropOffThisState = 5;
	overflow:false;
	underflow:false;
}

// counters for packages from Warehouse -> Houses
counter droneToHouseCap1(0..CAPACITY){
	droneToHouseCap1 = 0;
	inc: pickUpThisState = 9 | pickUpThisState =5;
	dec: dropOffThisState = 1;
	overflow:false;
	underflow:false;
}

counter droneToHouseCap2(0..CAPACITY){
	droneToHouseCap2 = 0;
	inc: pickUpThisState = 10 | pickUpThisState =6;
	dec: dropOffThisState = 2;
	overflow:false;
	underflow:false;
}

counter droneToHouseCap3(0..CAPACITY){
	droneToHouseCap3 = 0;
	inc: pickUpThisState = 11 | pickUpThisState = 7;
	dec: dropOffThisState = 3;
	overflow:false;
	underflow:false;
}

counter droneToHouseCap4(0..CAPACITY){
	droneToHouseCap4 = 0;
	inc: pickUpThisState = 12 | pickUpThisState = 8;
	dec: dropOffThisState = 4;
	overflow:false;
	underflow:false;
}

		
/* MONITORS TO WATCH PACKAGES WAIT TILL PICKED UP FROM OUT-HOUSE*/
monitor boolean waitingPackageOutHouse1{
	!waitingPackageOutHouse1;
	G waitingPackageOutHouse1 = (outHousePackages[0] = SMALL)  | PREV(waitingPackageOutHouse1);
}
monitor boolean waitingPackageOutHouse2{
	!waitingPackageOutHouse2;
	G waitingPackageOutHouse2 = (outHousePackages[1] = SMALL)  | PREV(waitingPackageOutHouse2);
}
monitor boolean waitingPackageOutHouse3{
	!waitingPackageOutHouse3;
	G waitingPackageOutHouse3 = (outHousePackages[2] = SMALL)  | PREV(waitingPackageOutHouse3);
}
monitor boolean waitingPackageOutHouse4{
	!waitingPackageOutHouse4;
	G waitingPackageOutHouse4 =(outHousePackages[3] = SMALL) | PREV(waitingPackageOutHouse4);
}

/* MONITORS TO WATCH PACKAGES WAIT TILL PICKED UP FROM WAREHOUSE*/
monitor boolean waitingPackageInWarehouseToHouse1{
	!waitingPackageInWarehouseToHouse1;
	G waitingPackageInWarehouseToHouse1 = (outWarehousePackages[0] = SMALL) | PREV(waitingPackageInWarehouseToHouse1); 
}
monitor boolean waitingPackageInWarehouseToHouse2{
	!waitingPackageInWarehouseToHouse2;
	G waitingPackageInWarehouseToHouse2 = (outWarehousePackages[1] = SMALL) | PREV(waitingPackageInWarehouseToHouse2); 
}
monitor boolean waitingPackageInWarehouseToHouse3{
	!waitingPackageInWarehouseToHouse3;
	G waitingPackageInWarehouseToHouse3 = (outWarehousePackages[2] = SMALL) | PREV(waitingPackageInWarehouseToHouse3); 
}
monitor boolean waitingPackageInWarehouseToHouse4{
	!waitingPackageInWarehouseToHouse4;
	G waitingPackageInWarehouseToHouse4 = (outWarehousePackages[3] = SMALL) | PREV(waitingPackageInWarehouseToHouse4); 
}
/* MONITORS TO WATCH PRIORITY PACKAGES WAIT TILL PICKED UP FROM WAREHOUSE*/
monitor boolean waitingPriorityPackageInWarehouseToHouse1{
	!waitingPriorityPackageInWarehouseToHouse1;
	G waitingPriorityPackageInWarehouseToHouse1 = (outWarehousePackages[0] = PRIORITY) | PREV(waitingPriorityPackageInWarehouseToHouse1); 
}
monitor boolean waitingPriorityPackageInWarehouseToHouse2{
	!waitingPriorityPackageInWarehouseToHouse2;
	G waitingPriorityPackageInWarehouseToHouse2 = (outWarehousePackages[1] = PRIORITY) | PREV(waitingPriorityPackageInWarehouseToHouse2); 
}
monitor boolean waitingPriorityPackageInWarehouseToHouse3{
	!waitingPriorityPackageInWarehouseToHouse3;
	G waitingPriorityPackageInWarehouseToHouse3 = (outWarehousePackages[2] = PRIORITY) | PREV(waitingPriorityPackageInWarehouseToHouse3); 
}
monitor boolean waitingPriorityPackageInWarehouseToHouse4{
	!waitingPriorityPackageInWarehouseToHouse4;
	G waitingPriorityPackageInWarehouseToHouse4 = (outWarehousePackages[3] = PRIORITY) | PREV(waitingPriorityPackageInWarehouseToHouse4); 
}

// guarantees

// Init location of drone at the start of the simulation
gar startAtChargingStation:
	atWarehouse;

// Init pickup/dropoff states
gar initPickUpThisState:
	pickUpThisState = 0;
gar initDropOffThisState:
	dropOffThisState = 0;
	
// Ensure at every step drone has to decide if to make a move in both row and col directions
gar droneAlwaysMoves:
	G moveDir(drone[0]) & moveDir(drone[1]);


// guarantees when a pickup can be made + implications on monitor
gar G pickUpThisState = 1 -> atHouse1 & waitingPackageOutHouse1 & roomForSmallPickup & next(waitingPackageOutHouse1)=false;
gar G pickUpThisState = 2 -> atHouse2 & waitingPackageOutHouse2 & roomForSmallPickup & next(waitingPackageOutHouse2)=false;
gar G pickUpThisState = 3 -> atHouse3 & waitingPackageOutHouse3 & roomForSmallPickup & next(waitingPackageOutHouse3)=false;
gar G pickUpThisState = 4 -> atHouse4 & waitingPackageOutHouse4 & roomForSmallPickup & next(waitingPackageOutHouse4)=false ;

gar G pickUpThisState = 5 -> atWarehouse & waitingPackageInWarehouseToHouse1 & roomForSmallPickup & next(waitingPackageInWarehouseToHouse1)=false;
gar G pickUpThisState = 6 -> atWarehouse & waitingPackageInWarehouseToHouse2 & roomForSmallPickup & next(waitingPackageInWarehouseToHouse2)=false;
gar G pickUpThisState = 7 -> atWarehouse & waitingPackageInWarehouseToHouse3 & roomForSmallPickup & next(waitingPackageInWarehouseToHouse3)=false ;
gar G pickUpThisState = 8 -> atWarehouse & waitingPackageInWarehouseToHouse4 & roomForSmallPickup & next(waitingPackageInWarehouseToHouse4)=false;

gar G pickUpThisState = 9 -> atWarehouse & waitingPriorityPackageInWarehouseToHouse1 & roomForSmallPickup & next(waitingPriorityPackageInWarehouseToHouse1)=false;
gar G pickUpThisState = 10 -> atWarehouse & waitingPriorityPackageInWarehouseToHouse2 & roomForSmallPickup & next(waitingPriorityPackageInWarehouseToHouse2)=false;
gar G pickUpThisState = 11 -> atWarehouse & waitingPriorityPackageInWarehouseToHouse3 & roomForSmallPickup & next(waitingPriorityPackageInWarehouseToHouse3)=false;
gar G pickUpThisState = 12 -> atWarehouse & waitingPriorityPackageInWarehouseToHouse4 & roomForSmallPickup & next(waitingPriorityPackageInWarehouseToHouse4)=false;

counter howManyRegularPickedWhilePriorityWaiting(0..5){
	howManyRegularPickedWhilePriorityWaiting=0; 
	inc: smallPackagePicked & priorityWaiting;
	reset: priorityPackagePicked;
	overflow: false; 
}
gar G howManyRegularPickedWhilePriorityWaiting <= 5;

// always eventually pick up a waiting package	
gar pRespondsToS(waitingPackageOutHouse1, pickUpThisState = 1);
gar pRespondsToS(waitingPackageOutHouse2, pickUpThisState = 2);
gar pRespondsToS(waitingPackageOutHouse3, pickUpThisState = 3);
gar pRespondsToS(waitingPackageOutHouse4, pickUpThisState = 4);
gar pRespondsToS(waitingPackageInWarehouseToHouse1, pickUpThisState = 5);
gar pRespondsToS(waitingPackageInWarehouseToHouse2, pickUpThisState = 6);
gar pRespondsToS(waitingPackageInWarehouseToHouse3, pickUpThisState = 7);
gar pRespondsToS(waitingPackageInWarehouseToHouse4, pickUpThisState = 8);
gar pRespondsToS(waitingPriorityPackageInWarehouseToHouse1, pickUpThisState = 9);
gar pRespondsToS(waitingPriorityPackageInWarehouseToHouse2, pickUpThisState = 10);
gar pRespondsToS(waitingPriorityPackageInWarehouseToHouse3, pickUpThisState = 11);
gar pRespondsToS(waitingPriorityPackageInWarehouseToHouse4, pickUpThisState = 12);


// guarantees when a drop-off can be made
gar G dropOffThisState = 1 -> atHouse1 & droneToHouseCap1 > 0;
gar G dropOffThisState = 2 -> atHouse2 & droneToHouseCap2 > 0;
gar G dropOffThisState = 3 -> atHouse3 & droneToHouseCap3 > 0;
gar G dropOffThisState = 4 -> atHouse4 & droneToHouseCap4 > 0;
gar G dropOffThisState = 5 -> atWarehouse & droneToWarehouseCap > 0;

// always eventually drop-off packages that are carried by the drone
gar pRespondsToS(droneToHouseCap1 > 0,atHouse1);
gar pRespondsToS(droneToHouseCap2 > 0,atHouse2);
gar pRespondsToS(droneToHouseCap3 > 0,atHouse3);
gar pRespondsToS(droneToHouseCap4 > 0,atHouse4);
gar pRespondsToS(droneToWarehouseCap > 0,atWarehouse);


counter energy (0..MAX_ENERGY){
	energy=0;
	inc: smallPackagePicked | priorityPackagePicked;
	reset: atChargingStation;
	overflow: false;
}
gar G energy <= MAX_ENERGY;
